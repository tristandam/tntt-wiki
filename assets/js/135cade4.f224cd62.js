"use strict";(self.webpackChunkiota_wiki=self.webpackChunkiota_wiki||[]).push([[66881],{44067:function(e,a,n){n.r(a),n.d(a,{assets:function(){return p},contentTitle:function(){return r},default:function(){return u},frontMatter:function(){return s},metadata:function(){return d},toc:function(){return m}});var t=n(83117),i=n(80102),o=(n(67294),n(3905)),l=["components"],s={description:"Mana is a reputation system for nodes within the IOTA network. Reputation is gained by contributing to the network. As time passes, part of the earned mana of a node decays to encourage keeping up the good behavior.",image:"/img/protocol_specification/mana.png",keywords:["mana","node","calculation","transactions","base mana","vectors","access mana","consensus mana","effective base mana","ledger state"]},r=void 0,d={unversionedId:"protocol_specification/components/mana",id:"protocol_specification/components/mana",title:"mana",description:"Mana is a reputation system for nodes within the IOTA network. Reputation is gained by contributing to the network. As time passes, part of the earned mana of a node decays to encourage keeping up the good behavior.",source:"@site/external/goshimmer/documentation/docs/protocol_specification/components/mana.md",sourceDirName:"protocol_specification/components",slug:"/protocol_specification/components/mana",permalink:"/goshimmer/protocol_specification/components/mana",editUrl:"https://github.com/iotaledger/goshimmer/edit/develop/external/goshimmer/documentation/docs/protocol_specification/components/mana.md",tags:[],version:"current",frontMatter:{description:"Mana is a reputation system for nodes within the IOTA network. Reputation is gained by contributing to the network. As time passes, part of the earned mana of a node decays to encourage keeping up the good behavior.",image:"/img/protocol_specification/mana.png",keywords:["mana","node","calculation","transactions","base mana","vectors","access mana","consensus mana","effective base mana","ledger state"]},sidebar:"docs",previous:{title:"autopeering",permalink:"/goshimmer/protocol_specification/components/autopeering"},next:{title:"congestion_control",permalink:"/goshimmer/protocol_specification/components/congestion_control"}},p={},m=[{value:"Introduction",id:"introduction",level:2},{value:"Scope",id:"scope",level:2},{value:"Mana Calculation",id:"mana-calculation",level:2},{value:"Challenges",id:"challenges",level:2},{value:"Dependency on Tangle",id:"dependency-on-tangle",level:3},{value:"Transaction Layout",id:"transaction-layout",level:3},{value:"Limitations",id:"limitations",level:2},{value:"Detailed Design",id:"detailed-design",level:2},{value:"Transaction",id:"transaction",level:3},{value:"Initialization",id:"initialization",level:3},{value:"Mana Package",id:"mana-package",level:3},{value:"Methods",id:"methods",level:4},{value:"Base Mana Calculation",id:"base-mana-calculation",level:4},{value:"A confirmed transaction pledges mana",id:"a-confirmed-transaction-pledges-mana",level:5},{value:"Any module accesses the Base Mana Vector",id:"any-module-accesses-the-base-mana-vector",level:5},{value:"Events",id:"events",level:4},{value:"Testing",id:"testing",level:4},{value:"Mana Plugin",id:"mana-plugin",level:3},{value:"Methods",id:"methods-1",level:4},{value:"Booking Mana",id:"booking-mana",level:4},{value:"Synchronization and Mana Calculation",id:"synchronization-and-mana-calculation",level:4},{value:"Mana Toolkit",id:"mana-toolkit",level:3},{value:"Mana Related API endpoints",id:"mana-related-api-endpoints",level:4},{value:"Metrics collection",id:"metrics-collection",level:4},{value:"Visualization",id:"visualization",level:4},{value:"Local Perception",id:"local-perception",level:5}],c={toc:m};function u(e){var a=e.components,s=(0,i.Z)(e,l);return(0,o.kt)("wrapper",(0,t.Z)({},c,s,{components:a,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"mana-implementation"},"Mana Implementation"),(0,o.kt)("p",null,"This document provides a high level overview of how mana is implemented in GoShimmer."),(0,o.kt)("h2",{id:"introduction"},"Introduction"),(0,o.kt)("p",null,"Mana is a reputation system for nodes within the IOTA network."),(0,o.kt)("p",null,"Reputation is gained by contributing to the network, i.e. creating value transfers.\nAs time passes, part of the earned mana of a node decays to encourage keeping up the good behavior."),(0,o.kt)("h2",{id:"scope"},"Scope"),(0,o.kt)("p",null,"The scope of the first implementation of mana into GoShimmer is to verify that mana calculations work,\nstudy base mana calculations 1 & 2, and mana distribution in the test network, furthermore to verify that nodes have\nsimilar view on the network."),(0,o.kt)("h2",{id:"mana-calculation"},"Mana Calculation"),(0,o.kt)("p",null,"Mana is essentially the reputation score of a node in the IOTA network. Mana is calculated locally in each node, as a\nfunction that takes value transactions as input and produces the Base Mana Vector as output."),(0,o.kt)("p",null,"Each transaction has an ",(0,o.kt)("inlineCode",{parentName:"p"},"accessMana")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"consensusMana")," field that determine which node to pledge these two types\nof mana to. Both of these fields denote a ",(0,o.kt)("inlineCode",{parentName:"p"},"nodeID"),", the receiver of mana. ",(0,o.kt)("inlineCode",{parentName:"p"},"accessMana")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"consensusMana")," do not have\nto be pledged to the same node, but for simplicity, in the first implementation, they will be."),(0,o.kt)("p",null,"In addition to the mana fields, a ",(0,o.kt)("inlineCode",{parentName:"p"},"timestamp")," field is also added to the transactions that will be utilized for calculating\ndecay and effective mana."),(0,o.kt)("p",null,"From the pledged mana of a transaction, a node can calculate locally the ",(0,o.kt)("inlineCode",{parentName:"p"},"Base Mana Vector")," for both ",(0,o.kt)("inlineCode",{parentName:"p"},"Access Mana")," and\n",(0,o.kt)("inlineCode",{parentName:"p"},"Consensus Mana"),"."),(0,o.kt)("p",null,"A ",(0,o.kt)("inlineCode",{parentName:"p"},"Base Mana Vector")," consists of Base Mana 1 and Base Mana 2 and their respective ",(0,o.kt)("inlineCode",{parentName:"p"},"Effective Base Mana"),".\nGiven a value transaction, Base Mana 1 and Base Mana 2 are determined as follows:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Base Mana 1 is revoked from the node that created the output(s) used as input(s) in the transaction, and is pledged to\nthe node creating the new output(s). The amount of ",(0,o.kt)("inlineCode",{parentName:"li"},"Base Mana 1")," revoked and pledged is equal to the balance of the\ninput."),(0,o.kt)("li",{parentName:"ol"},"Base Mana 2 is freshly created at the issuance time of the transaction, awarded to the node, but decays with time.\nThe amount of ",(0,o.kt)("inlineCode",{parentName:"li"},"Base Mana 2")," pledged is determined with ",(0,o.kt)("inlineCode",{parentName:"li"},"Pending Mana")," concept: funds sitting at an address generate\n",(0,o.kt)("inlineCode",{parentName:"li"},"pending mana")," that grows over time, but bounded.",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"Mana_pending = (alpha*S)/gamma*(1-e^(-gamma*t))"),", where ",(0,o.kt)("inlineCode",{parentName:"li"},"alpha")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"gamma")," are chosen parameters, ",(0,o.kt)("inlineCode",{parentName:"li"},"S")," is the amount\nof funds an output transfers to the address, and ",(0,o.kt)("inlineCode",{parentName:"li"},"t")," is the time since the funds are on that address.")))),(0,o.kt)("p",null,"An example ",(0,o.kt)("inlineCode",{parentName:"p"},"Base Mana Vector")," for ",(0,o.kt)("inlineCode",{parentName:"p"},"Access Mana")," could look like this:"),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null}),(0,o.kt)("th",{parentName:"tr",align:null},"Node 1"),(0,o.kt)("th",{parentName:"tr",align:null},"Node 2"),(0,o.kt)("th",{parentName:"tr",align:null},"..."),(0,o.kt)("th",{parentName:"tr",align:null},"Node k"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"Base Mana 1"),(0,o.kt)("td",{parentName:"tr",align:null},"0"),(0,o.kt)("td",{parentName:"tr",align:null},"1"),(0,o.kt)("td",{parentName:"tr",align:null},"..."),(0,o.kt)("td",{parentName:"tr",align:null},"100.54")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"Effective Base Mana 1"),(0,o.kt)("td",{parentName:"tr",align:null},"0"),(0,o.kt)("td",{parentName:"tr",align:null},"0.5"),(0,o.kt)("td",{parentName:"tr",align:null},"..."),(0,o.kt)("td",{parentName:"tr",align:null},"120.7")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"Base Mana 2"),(0,o.kt)("td",{parentName:"tr",align:null},"0"),(0,o.kt)("td",{parentName:"tr",align:null},"1.2"),(0,o.kt)("td",{parentName:"tr",align:null},"..."),(0,o.kt)("td",{parentName:"tr",align:null},"0.01")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"Effective Base Mana 2"),(0,o.kt)("td",{parentName:"tr",align:null},"0"),(0,o.kt)("td",{parentName:"tr",align:null},"0.6"),(0,o.kt)("td",{parentName:"tr",align:null},"..."),(0,o.kt)("td",{parentName:"tr",align:null},"0.015")))),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"Base Mana")," is pledged or revoked at discrete times, which results in ",(0,o.kt)("inlineCode",{parentName:"p"},"Base Mana"),' being discontinuous function over time.\nIn order to make mana "smoother" and continuous, an exponential moving average is applied to the ',(0,o.kt)("inlineCode",{parentName:"p"},"Base Mana")," values,\nresulting in ",(0,o.kt)("inlineCode",{parentName:"p"},"Effective Base Mana 1")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"Effective Base Mana 2"),"."),(0,o.kt)("p",null,"It is important to note, that consuming a new transaction and pledging its mana happens when the transaction is\nconfirmed on the node. At the same time, entries of the nodes whose mana is being modified during pledging in the\n",(0,o.kt)("inlineCode",{parentName:"p"},"Base Mana Vector(s)")," are updated with respect to time. In general, updates due to time happen whenever a node's mana is\nbeing accessed. Except for the aforementioned case, this could be for example a mana related query from an external\nmodule (AutoPeering, DRNG, Rate Control, tools, etc.)."),(0,o.kt)("p",null,"Following figure summarizes how ",(0,o.kt)("inlineCode",{parentName:"p"},"Access Mana")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"Consensus Mana")," is derived from a transaction:"),(0,o.kt)("p",null,(0,o.kt)("a",{target:"_blank",href:n(35085).Z},(0,o.kt)("img",{alt:"Mana",src:n(18029).Z,title:"Mana",width:"681",height:"446"}))),(0,o.kt)("p",null,"The reason for having two separate ",(0,o.kt)("inlineCode",{parentName:"p"},"Base Mana Vectors")," is the fact, that ",(0,o.kt)("inlineCode",{parentName:"p"},"accessMana")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"consensusMana")," can be pledged\nto different nodes."),(0,o.kt)("p",null,"The exact mathematical formulas, and their respective parameters will be determined later."),(0,o.kt)("h2",{id:"challenges"},"Challenges"),(0,o.kt)("h3",{id:"dependency-on-tangle"},"Dependency on Tangle"),(0,o.kt)("p",null,'Since mana is awarded to nodes submitting value transfers, the tangle is needed as input for mana calculation.\nEach node calculates mana locally, therefore, it is essential to determine when to consider transactions in the\ntangle "final enough" (so that they will not be orphaned).'),(0,o.kt)("p",null,"When a transaction is ",(0,o.kt)("inlineCode",{parentName:"p"},"confirmed"),", it is a sufficient indicator that it will not be orphaned. However, in current\nGoShimmer implementation, confirmation is not yet a properly defined concept. This issue will be addressed in a separate\nmodule."),(0,o.kt)("p",null,"The Mana module assumes, that the (value) tangle's ",(0,o.kt)("inlineCode",{parentName:"p"},"TransactionConfirmed")," event is the trigger condition to update the\nmana state machine (base mana vectors for access and consensus mana). Once the concept of transaction finality is\nintroduced for the tangle, the trigger conditions for access and consensus mana calculations can be adjusted."),(0,o.kt)("h3",{id:"transaction-layout"},"Transaction Layout"),(0,o.kt)("p",null,"A new field should be added to ",(0,o.kt)("inlineCode",{parentName:"p"},"Transaction")," denoting ",(0,o.kt)("inlineCode",{parentName:"p"},"PledgedNodeID")," for ",(0,o.kt)("inlineCode",{parentName:"p"},"Access Mana")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"Consensus Mana"),".\nThis is also beneficial to implement mana donation feature, that is, to donate the mana of a certain transaction to an\narbitrary node."),(0,o.kt)("h2",{id:"limitations"},"Limitations"),(0,o.kt)("p",null,"The first implementation of mana in GoShimmer will:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"not have voted timestamps on value transactions,"),(0,o.kt)("li",{parentName:"ul"},"lack proper ",(0,o.kt)("inlineCode",{parentName:"li"},"TransactionConfirmed")," mechanism to trigger mana update,"),(0,o.kt)("li",{parentName:"ul"},"lack integration into rate control/autopeering/etc.")),(0,o.kt)("h2",{id:"detailed-design"},"Detailed Design"),(0,o.kt)("p",null,"In this section, detailed GoShimmer implementation design considerations will be outlined about the mana module.\nIn short, changes can be classified into 3 categories:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Transaction related changes,"),(0,o.kt)("li",{parentName:"ol"},"Mana module functionality,"),(0,o.kt)("li",{parentName:"ol"},"and related tools/utilities, such as API, visualization, analytics.")),(0,o.kt)("h3",{id:"transaction"},"Transaction"),(0,o.kt)("p",null,"As described above, 3 new fields will be added to the transaction layout:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("inlineCode",{parentName:"li"},"Timestamp")," time.time"),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("inlineCode",{parentName:"li"},"AccessManaNodeID")," []bytes"),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("inlineCode",{parentName:"li"},"ConsensusManaNodeID")," []bytes")),(0,o.kt)("p",null,"By adding these fields to the signed transaction, ",(0,o.kt)("inlineCode",{parentName:"p"},"valuetransfers/packages/transaction")," should be modified."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"The three new fields should be added to the transaction essence."),(0,o.kt)("li",{parentName:"ul"},"Marshalling and unmarshalling of a transaction should be modified."),(0,o.kt)("li",{parentName:"ul"},"For calculating ",(0,o.kt)("inlineCode",{parentName:"li"},"Base Mana 1")," values, ",(0,o.kt)("inlineCode",{parentName:"li"},"mana module")," should be able to derive from a transaction the nodes which received\npledged ",(0,o.kt)("inlineCode",{parentName:"li"},"Base Mana 1")," as a consequence of the consumed inputs of the transaction. Therefore, a lookup function should\nbe exposed from the value tangle that given an ",(0,o.kt)("inlineCode",{parentName:"li"},"input"),", returns the ",(0,o.kt)("inlineCode",{parentName:"li"},"pledgedNodeID")," of the transaction creating the input.")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"Timestamp")," is part of the signed transaction, therefore, a client sending a transaction to the node should already\ndefine it. In this case, this ",(0,o.kt)("inlineCode",{parentName:"p"},"Timestamp")," will not be the same as the timestamp of the message containing the\ntransaction and value payload, since the message is created on the node.\nA solution to this is that upon receiving a ",(0,o.kt)("inlineCode",{parentName:"p"},"transaction")," from a client, the node checks if the timestamp is within\na predefined time window, for example ",(0,o.kt)("inlineCode",{parentName:"p"},"t_current - delta"),", where ",(0,o.kt)("inlineCode",{parentName:"p"},"delta")," could be couple seconds. If true, then the node\nconstructs the message, which must have a greater timestamp, than the transaction."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"AccessManaNodeID")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"ConsensusManaNodeID")," are also part of the signed transaction, so a client should fill them out.\nNode owners are free to choose to whom they pledge mana to with the transaction, so there should be a mechanism that\nlets the client know, what ",(0,o.kt)("inlineCode",{parentName:"p"},"AccessManaNodeID")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"ConsensusManaNodeID")," are allowed. This could be a new API endpoint\nthat works like this:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Client asks node what nodeIDs can be included for pledging  a certain type (access, consensus) mana."),(0,o.kt)("li",{parentName:"ol"},"Node answers with either:")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Don't care. Any node IDs are valid."),(0,o.kt)("li",{parentName:"ul"},"List of nodeIDs that are allowed for each type.")),(0,o.kt)("ol",{start:3},(0,o.kt)("li",{parentName:"ol"},"If a client sends back the transaction with invalid or empty mana fields, the transaction is considered invalid.")),(0,o.kt)("p",null,"This way node owners can decide who their transactions are pledging mana to. It could be only their node, or they could\nprovide mana pledging as a service. They could delegate access mana to others, but hold own to consensus mana, or the\nother way around."),(0,o.kt)("h3",{id:"initialization"},"Initialization"),(0,o.kt)("p",null,"Mana state machine is an extension of the ledger state, hence its calculation depends on the ledger state perception\nof the node. Snapshotting is the mechanism that saves the ledger states and prunes unnecessary transactions. Together\nwith the ledger state, base mana vectors are also saved, since a certain ledger state reflects a certain mana distribution\nin the network. In future, when snapshotting is implemented in GoShimmer, nodes joining the network will be able to query\nfor snapshot files that will contain initial base mana vectors as well."),(0,o.kt)("p",null,"Until this functionality is implemented, mana calculation solely relies on transactions getting confirmed. That is, when\na node joins the network and starts gathering messages and transactions from peers, it builds its own ledger state through\nsolidification process. Essentially, the node requests all messages down to the genesis from the current tips of its neighbors.\nOnce the genesis is found, messages are solidified bottom up. For the value tangle, this means that for each solidified\nand liked transaction, ",(0,o.kt)("inlineCode",{parentName:"p"},"TransactionConfirmed")," event is triggered, updating the base mana vectors."),(0,o.kt)("p",null,'In case of a large database, initial synching and solidification is a computationally heavy task due to the sheer amount\nof messages in the tangle. Mana calculation only adds to this burden. It will be determined through testing if additional\n"weight lifting" mechanism is needed (for example delaying mana calculation).'),(0,o.kt)("p",null,"In the GoShimmer test network, all funds are initially held by the faucet node, therefore all mana present at bootstrap belong\nto this node. Whenever a transaction is requested from the faucet, it pledges mana to the requesting node, helping other\nnodes to increase their mana."),(0,o.kt)("h3",{id:"mana-package"},"Mana Package"),(0,o.kt)("p",null,"The functionality of the mana module should be implemented in a ",(0,o.kt)("inlineCode",{parentName:"p"},"mana")," package. Then, a ",(0,o.kt)("inlineCode",{parentName:"p"},"mana plugin")," can use the package\nstructs and methods to connect the dots, for example execute ",(0,o.kt)("inlineCode",{parentName:"p"},"BookMana")," when ",(0,o.kt)("inlineCode",{parentName:"p"},"TransactionConfirmed")," event is triggered\nin the value tangle."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"BaseMana")," is a struct that holds the different mana values for a given node.\nNote that except for ",(0,o.kt)("inlineCode",{parentName:"p"},"Base Mana 1")," calculation, we need the time when ",(0,o.kt)("inlineCode",{parentName:"p"},"BaseMana")," values were updated, so we store it in the struct:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"type BaseMana struct {\n BaseMana1 float\n EffectiveBaseMana1 float\n BaseMana2 float\n EffectiveBaseMana2 float\n LastUpdated time\n}\n")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"BaseManaVector")," is a data structure that maps ",(0,o.kt)("inlineCode",{parentName:"p"},"nodeID"),"s to ",(0,o.kt)("inlineCode",{parentName:"p"},"BaseMana"),". It also has a ",(0,o.kt)("inlineCode",{parentName:"p"},"Type")," that denotes the type\nof mana this vector deals with (Access, Consensus, etc.)."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"type BaseManaVector struct {\n    vector     map[identity.ID]*BaseMana\n    vectorType Type\n}\n")),(0,o.kt)("h4",{id:"methods"},"Methods"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"BaseManaVector")," should have the following methods:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"BookMana(transaction)"),": Book mana of a transaction. Trigger ",(0,o.kt)("inlineCode",{parentName:"li"},"ManaBooked")," event. Note, that this method updates\n",(0,o.kt)("inlineCode",{parentName:"li"},"BaseMana")," with respect to time and to new ",(0,o.kt)("inlineCode",{parentName:"li"},"Base Mana 1")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"Base Mana 2")," values."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"GetWeightedMana(nodeID, weight) mana"),": Return ",(0,o.kt)("inlineCode",{parentName:"li"},"weight")," *",(0,o.kt)("inlineCode",{parentName:"li"}," Effective Base Mana 1")," + (1-",(0,o.kt)("inlineCode",{parentName:"li"},"weight"),")+",(0,o.kt)("inlineCode",{parentName:"li"},"Effective Base Mana 2"),".\n",(0,o.kt)("inlineCode",{parentName:"li"},"weight")," is a number in ","[0,1]"," interval. Notice, that ",(0,o.kt)("inlineCode",{parentName:"li"},"weight")," = 1  results in only returning ",(0,o.kt)("inlineCode",{parentName:"li"},"Effective Base Mana 1"),",\nand the other way around. Note, that this method also updates ",(0,o.kt)("inlineCode",{parentName:"li"},"BaseMana")," of the node with respect to time."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"GetMana(nodeID) mana"),": Return 0.5",(0,o.kt)("em",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"em"},"Effective Base Mana 1")," + 0.5"),(0,o.kt)("inlineCode",{parentName:"li"},"Effective Base Mana 2")," of a particular node. Note, that\nthis method also updates ",(0,o.kt)("inlineCode",{parentName:"li"},"BaseMana")," of the node with respect to time."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"update(nodeID, time)"),": update ",(0,o.kt)("inlineCode",{parentName:"li"},"Base Mana 2"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"Effective Base Mana 1")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"Effective Base Mana 2")," of a node with respect ",(0,o.kt)("inlineCode",{parentName:"li"},"time"),"."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"updateAll(time)"),": update ",(0,o.kt)("inlineCode",{parentName:"li"},"Base Mana 2"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"Effective Base Mana 1")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"Effective Base Mana 2")," of all nodes with respect to ",(0,o.kt)("inlineCode",{parentName:"li"},"time"),".")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"BaseMana")," should have the following methods:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"pledgeAndUpdate(transaction)"),": update ",(0,o.kt)("inlineCode",{parentName:"li"},"BaseMana")," fields and pledge mana with respect to ",(0,o.kt)("inlineCode",{parentName:"li"},"transaction"),"."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"revokeBaseMana1(amount, time)"),":  update ",(0,o.kt)("inlineCode",{parentName:"li"},"BaseMana")," values with respect to ",(0,o.kt)("inlineCode",{parentName:"li"},"time")," and revoke ",(0,o.kt)("inlineCode",{parentName:"li"},"amount")," ",(0,o.kt)("inlineCode",{parentName:"li"},"BaseMana1"),"."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"update(time)"),": update all ",(0,o.kt)("inlineCode",{parentName:"li"},"BaseMana")," fields with respect to ",(0,o.kt)("inlineCode",{parentName:"li"},"time"),"."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"updateEBM1(time)"),": update ",(0,o.kt)("inlineCode",{parentName:"li"},"Effective Base Mana 1")," wrt to ",(0,o.kt)("inlineCode",{parentName:"li"},"time"),"."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"updateBM2(time)"),": update ",(0,o.kt)("inlineCode",{parentName:"li"},"Base Mana 2")," wrt to ",(0,o.kt)("inlineCode",{parentName:"li"},"time"),"."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"updateEBM2(time)"),": update ",(0,o.kt)("inlineCode",{parentName:"li"},"Effective Base Mana 2")," wrt to ",(0,o.kt)("inlineCode",{parentName:"li"},"time"),".")),(0,o.kt)("h4",{id:"base-mana-calculation"},"Base Mana Calculation"),(0,o.kt)("p",null,"There are two cases when the values within ",(0,o.kt)("inlineCode",{parentName:"p"},"Base Mana Vector")," are updated:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"A confirmed transaction pledges mana."),(0,o.kt)("li",{parentName:"ol"},"Any module accesses the ",(0,o.kt)("inlineCode",{parentName:"li"},"Base Mana Vector"),", and hence its values are updated with respect to ",(0,o.kt)("inlineCode",{parentName:"li"},"access time"),".")),(0,o.kt)("p",null,"First, let's explore the former."),(0,o.kt)("h5",{id:"a-confirmed-transaction-pledges-mana"},"A confirmed transaction pledges mana"),(0,o.kt)("p",null,"For simplicity, we only describe mana calculation for one of the Base Mana Vectors, namely, the Base Access Mana Vector."),(0,o.kt)("p",null,"First, a ",(0,o.kt)("inlineCode",{parentName:"p"},"TransactionConfirmed")," event is triggered, therefore ",(0,o.kt)("inlineCode",{parentName:"p"},"BaseManaVector.BookMana(transaction)")," is executed:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"func (bmv *BaseManaVector) BookMana(tx *transaction) {\n    pledgedNodeID := tx.accessMana\n\n    for input := range tx.inputs {\n        // search for the nodeID that the input's tx pledged its mana to\n        inputNodeID := loadPledgedNodeIDFromInput(input)\n        // save it for proper event trigger\n        oldMana := bmv[inputNodeID]\n        // revoke BM1\n        bmv[inputNodeID].revokeBaseMana1(input.balance, tx.timestamp)\n\n        // trigger events\n        Events.ManaRevoked.Trigger(&ManaRevokedEvent{inputNodeID, input.balance, tx.timestamp, AccessManaType})\n        Events.ManaUpdated.Tigger(&ManaUpdatedEvent{inputNodeID, oldMana, bmv[inputNodeID], AccessManaType})\n    }\n\n    // save it for proper event trigger\n    oldMana :=  bmv[pledgedNodeID]\n    // actually pledge and update\n    bm1Pledged, bm2Pledged := bmv[pledgedNodeID].pledgeAndUpdate(tx)\n\n    // trigger events\n    Events.ManaPledged.Trigger(&ManaPledgedEvent{pledgedNodeID, bm1Pledged, bm2Pledged, tx.timestamp, AccessManaType})\n    Events.ManaUpdated.Trigger(&ManaUpdatedEvent{pledgedNodeID, oldMana, bmv[pledgedNodeID], AccessManaType})\n}\n")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"Base Mana 1")," is being revoked from the nodes that pledged mana for inputs that the current transaction consumes.\nThen, the appropriate node is located in ",(0,o.kt)("inlineCode",{parentName:"p"},"Base Mana Vector"),", and mana is pledged to its ",(0,o.kt)("inlineCode",{parentName:"p"},"BaseMana"),".\n",(0,o.kt)("inlineCode",{parentName:"p"},"Events")," are essential to study what happens within the module from the outside."),(0,o.kt)("p",null,"Note, that ",(0,o.kt)("inlineCode",{parentName:"p"},"revokeBaseMana1")," accesses the mana entry of the nodes within ",(0,o.kt)("inlineCode",{parentName:"p"},"Base Mana Vector"),", therefore all values are\nupdated with respect to ",(0,o.kt)("inlineCode",{parentName:"p"},"t"),". Notice the two branches after the condition. When ",(0,o.kt)("inlineCode",{parentName:"p"},"Base Mana")," values had been updated before\nthe transaction's timestamp, a regular update is carried out. However, if ",(0,o.kt)("inlineCode",{parentName:"p"},"t"),' is older, than the transaction timestamp,\nan update in the "past" is carried out and values are updated up to ',(0,o.kt)("inlineCode",{parentName:"p"},"LastUpdated"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"func (bm *BaseMana) revokeBaseMana1(amount float64, t time.Time) {\n    if t.After(bm.LastUpdated) {\n        // regular update\n        n := t.Sub(bm.LastUpdated)\n        // first, update EBM1, BM2 and EBM2 until `t`\n        bm.updateEBM1(n)\n        bm.updateBM2(n)\n        bm.updateEBM2(n)\n\n        bm.LastUpdated = t\n        // revoke BM1 at `t`\n        bm.BaseMana1 -= amount\n    } else {\n        // update in past\n        n := bm.LastUpdated.Sub(t)\n        // revoke BM1 at `t`\n        bm.BaseMana1 -= amount\n        // update EBM1 to `bm.LastUpdated`\n        bm.EffectiveBaseMana1 -= amount*(1-math.Pow(math.E,-EMA_coeff_1*n))\n    }\n}\n")),(0,o.kt)("p",null,"The same regular and past update scheme is applied to pledging mana too:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"func (bm *BaseMana) pledgeAndUpdate(tx *transaction) (bm1Pledged int, bm2Pledged int){\n    t := tx.timestamp\n    bm1Pledged = sum_balance(tx.inputs)\n\n    if t.After(bm.LastUpdated) {\n        // regular update\n        n := t.Sub(bm.LastUpdated)\n        // first, update EBM1, BM2 and EBM2 until `t`\n        bm.updateEBM1(n)\n        bm.updateBM2(n)\n        bm.updateEBM2(n)\n        bm.LastUpdated = t\n        bm.BaseMana1 += bm1Pledged\n        // pending mana awarded, need to see how long funds sat\n        for input := range tx.inputs {\n            // search for the timestamp of the UTXO that generated the input\n            t_inp := LoadTxTimestampFromOutputID(input)\n            bm2Add := input.balance * (1 - math.Pow(math.E, -decay*(t-t_inp)))\n            bm.BaseMana2 += bm2Add\n            bm2Pledged += bm2Add\n        }\n    } else {\n        // past update\n        n := bm.LastUpdated.Sub(t)\n        // update BM1 and BM2 at `t`\n        bm.BaseMana1 += bm1Pledged\n        oldMana2 = bm.BaseMana2\n        for input := range tx.inputs {\n            // search for the timestamp of the UTXO that generated the input\n            t_inp := LoadTxTimestampFromOutputID(input)\n            bm2Add := input.balance * (1-math.Pow( math.E,-decay*(t-t_inp) ) ) * math.Pow(math.E, -decay*n)\n            bm.BaseMana2 += bm2Add\n            bm2Pledged += bm2Add\n        }\n        // update EBM1 and EBM2 to `bm.LastUpdated`\n        bm.EffectiveBaseMana1 += amount*(1-math.Pow(math.E,-EMA_coeff_1*n))\n        if EMA_coeff_2 != decay {\n            bm.EffectiveBaseMana2 += (bm.BaseMana2 - oldMana2) *EMA_coeff_2*(math.Pow(math.E,-decay*n)-\n                math.Pow(math.E,-EMA_coeff_2*n))/(EMA_coeff_2-decay) / math.Pow(math.E, -decay*n)\n        } else {\n            bm.EffectiveBaseMana2 += (bm.BaseMana2 - oldMana2) * decay * n\n        }\n}\n    return bm1Pledged, bm2Pledged\n}\n")),(0,o.kt)("p",null,"Notice, that in case of ",(0,o.kt)("inlineCode",{parentName:"p"},"EMA_coeff_2 = decay"),", a simplified formula can be used to calculate ",(0,o.kt)("inlineCode",{parentName:"p"},"EffectiveBaseMana2"),".\nThe same approach is applied in ",(0,o.kt)("inlineCode",{parentName:"p"},"updateEBM2()"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"func (bm *BaseMana) updateEBM1(n time.Duration) {\n    bm.EffectiveBaseMana1 = math.Pow(math.E, -EMA_coeff_1 * n) * bm.EffectiveBaseMana1 +\n                                 (1-math.Pow(math.E, -EMA_coeff_1 * n)) * bm.BaseMana1\n}\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"func (bm *BaseMana) updateBM2(n time.Duration) {\n    bm.BaseMana2 = bm.BaseMana2 * math.Pow(math.E, -decay*n)\n}\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"func (bm *BaseMana) updateEBM2(n time.Duration) {\n    if EMA_coeff_2 != decay {\n        bm.EffectiveBaseMana2 = math.Pow(math.E, -emaCoeff2 * n) * bm.EffectiveBaseMana2 +\n            (math.Pow(math.E, -decay * n) - math.Pow(math.E, -EMA_coeff_2 * n)) /\n                (EMA_coeff_2 - decay) * EMA_coeff_2 / math.Pow(math.E, -decay * n)*bm.BaseMana2\n    } else {\n        bm.EffectiveBaseMana2 = math.Pow(math.E, -decay * n)*bm.EffectiveBaseMana2 +\n            decay * n * bm.BaseMana2\n    }\n}\n")),(0,o.kt)("h5",{id:"any-module-accesses-the-base-mana-vector"},"Any module accesses the Base Mana Vector"),(0,o.kt)("p",null,"In this case, the accessed entries within ",(0,o.kt)("inlineCode",{parentName:"p"},"Base Mana Vector")," are updated via the method:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"func (bmv *BaseManaVector) update(nodeID ID, t time.Time ) {\n    oldMana :=  bmv[nodeID]\n    bmv[nodeID].update(t)\n    Events.ManaUpdated.Trigger(&ManaUpdatedEvent{nodeID, oldMana, bmv[nodeID], AccessManaType})\n}\n")),(0,o.kt)("p",null,"where ",(0,o.kt)("inlineCode",{parentName:"p"},"t")," is the access time."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"func (bm *BaseMana) update(t time.Time ) {\n    n := t - bm.LastUpdated\n    bm.updateEBM1(n)\n    bm.updateBM2(n)\n    bm.updateEBM2(n)\n\n    bm.LastUpdated = t\n}\n")),(0,o.kt)("h4",{id:"events"},"Events"),(0,o.kt)("p",null,"The mana package should have the following events:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"Pledged")," when mana (",(0,o.kt)("inlineCode",{parentName:"li"},"BM1")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"BM2"),") was pledged for a node due to new transactions being confirmed.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"type PledgedEvent struct {\n    NodeID []bytes\n    AmountBM1 int\n    AmountBM2 int\n    Time time.Time\n    Type ManaType // access or consensus\n}\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"Revoked")," when mana (",(0,o.kt)("inlineCode",{parentName:"li"},"BM1"),") was revoked from a node.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"type RevokedEvent struct {\n    NodeID []bytes\n    AmountBM1 int\n    Time time.Time\n    Type ManaType // access or consensus\n}\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"Updated")," when mana was updated for a node due to it being accessed.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"type UpdatedEvent struct {\n    NodeID []bytes\n    OldMana BaseMana\n    NewMana BaseMana\n    Type    ManaType // access or consensus\n}\n")),(0,o.kt)("h4",{id:"testing"},"Testing"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Write unit tests for all methods."),(0,o.kt)("li",{parentName:"ul"},"Test all events and if they are correctly triggered."),(0,o.kt)("li",{parentName:"ul"},"Benchmark calculations in tests to see how heavy it is to calculate EMAs and decays.")),(0,o.kt)("h3",{id:"mana-plugin"},"Mana Plugin"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"mana plugin")," is responsible for:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"calculating mana from value transactions,"),(0,o.kt)("li",{parentName:"ul"},"keeping a log of the different mana values of all nodes,"),(0,o.kt)("li",{parentName:"ul"},"updating mana values,"),(0,o.kt)("li",{parentName:"ul"},"responding to mana related queries from other modules,"),(0,o.kt)("li",{parentName:"ul"},"saving base mana vectors in database when shutting down the node,"),(0,o.kt)("li",{parentName:"ul"},"trying to load base mana vectors from database when starting the node.")),(0,o.kt)("p",null,"The proposed mana plugin should keep track of the different mana values of nodes and handle calculation\nupdates. Mana values are mapped to ",(0,o.kt)("inlineCode",{parentName:"p"},"nodeID"),"s and stored in a ",(0,o.kt)("inlineCode",{parentName:"p"},"map")," data structure. The vector also stores information on\nwhat ",(0,o.kt)("inlineCode",{parentName:"p"},"Type")," of mana it handles."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"type BaseManaVector struct {\n    vector     map[identity.ID]*BaseMana\n    vectorType Type\n}\n")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"Access Mana")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"Consensus Mana")," should have their own respective ",(0,o.kt)("inlineCode",{parentName:"p"},"BaseManaVector"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"accessManaVector := BaseManaVector{vectorType: AccesMana}\nconsensusManaVector :=  BaseManaVector{vectorType: ConsensusMana}\n")),(0,o.kt)("p",null,"In the future, it should be possible to combine ",(0,o.kt)("inlineCode",{parentName:"p"},"Effective Base Mana 1")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"Effective Base Mana 2")," from a ",(0,o.kt)("inlineCode",{parentName:"p"},"BaseManaVector"),"\nin arbitrary proportions to arrive at a final mana value that other modules use. The ",(0,o.kt)("inlineCode",{parentName:"p"},"mana package")," has these methods\nin place. Additionally, a parameter could be passed to the ",(0,o.kt)("inlineCode",{parentName:"p"},"getMana")," type of exposed functions to set the proportions."),(0,o.kt)("h4",{id:"methods-1"},"Methods"),(0,o.kt)("p",null,"The mana plugin should expose utility functions to other modules:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"GetHighestManaNodes(type, n) [n]NodeIdManaTuple"),": return the ",(0,o.kt)("inlineCode",{parentName:"li"},"n")," highest ",(0,o.kt)("inlineCode",{parentName:"li"},"type")," mana nodes (",(0,o.kt)("inlineCode",{parentName:"li"},"nodeID"),",",(0,o.kt)("inlineCode",{parentName:"li"},"manaValue"),") in\nascending order. Should also update their mana value."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"GetManaMap(type) map[nodeID]manaValue"),": return ",(0,o.kt)("inlineCode",{parentName:"li"},"type")," mana perception of the node."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"GetAccessMana(nodeID) mana"),": access ",(0,o.kt)("inlineCode",{parentName:"li"},"Base Mana Vector")," of ",(0,o.kt)("inlineCode",{parentName:"li"},"Access Mana"),", update its values with respect to time,\nand return the amount of ",(0,o.kt)("inlineCode",{parentName:"li"},"Access Mana")," (either ",(0,o.kt)("inlineCode",{parentName:"li"},"Effective Base Mana 1"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"Effective Base Mana 2"),", or some combination\nof the two). Trigger ",(0,o.kt)("inlineCode",{parentName:"li"},"ManaUpdated")," event."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"GetConsensusMana(nodeID) mana"),": access ",(0,o.kt)("inlineCode",{parentName:"li"},"Base Mana Vector")," of ",(0,o.kt)("inlineCode",{parentName:"li"},"Consensus Mana"),", update its values with respect to time,\nand returns the amount of ",(0,o.kt)("inlineCode",{parentName:"li"},"Consensus Mana")," (either ",(0,o.kt)("inlineCode",{parentName:"li"},"Effective Base Mana 1"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"Effective Base Mana 2"),", or some combination\nof the two). Trigger ",(0,o.kt)("inlineCode",{parentName:"li"},"ManaUpdated")," event."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"GetNeighborsMana(type)"),": returns the ",(0,o.kt)("inlineCode",{parentName:"li"},"type")," mana of the nodes neighbors"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"GetAllManaVectors()")," Obtaining the full mana maps for comparison with the perception of other nodes."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"GetWeightedRandomNodes(n)"),": returns a weighted random selection of ",(0,o.kt)("inlineCode",{parentName:"li"},"n")," nodes. ",(0,o.kt)("inlineCode",{parentName:"li"},"Consensus Mana")," is used for the weights."),(0,o.kt)("li",{parentName:"ul"},"Obtaining a list of currently known peers + their mana, sorted. Useful for knowing which high mana nodes are online."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"OverrideMana(nodeID, baseManaVector)"),": Sets the nodes mana to a specific value. Can be useful for debugging, setting faucet mana, initialization, etc.. Triggers ",(0,o.kt)("inlineCode",{parentName:"li"},"ManaUpdated"))),(0,o.kt)("p",null,"Such utility functions could be used for example to visualize mana distribution in node dashboard, or send neighbor\nmana data to the analysis server for further processing."),(0,o.kt)("h4",{id:"booking-mana"},"Booking Mana"),(0,o.kt)("p",null,"Mana is booked when a transaction is confirmed."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"on TransactionConfirmed (tx):\n bookAccessMana()\n bookConsensusMana()\n")),(0,o.kt)("h4",{id:"synchronization-and-mana-calculation"},"Synchronization and Mana Calculation"),(0,o.kt)("p",null,"The mana plugin is responsible to determine when to start calculating mana locally.\nSince mana state is an extension to ledger state, it can only depict realistic mana values once the node is in sync.\nDuring syncing, ledger state is constructed from messages coming from neighbors as described further above."),(0,o.kt)("p",null,"In this first iteration, mana plugin relies on ",(0,o.kt)("inlineCode",{parentName:"p"},"TransactionConfirmed")," event of the value transfers plugin, and has no\nexplicit rules on when to start and stop mana calculation."),(0,o.kt)("p",null,"In future, initial mana state (together with the initial ledger state) will be derived from a snapshot file."),(0,o.kt)("h3",{id:"mana-toolkit"},"Mana Toolkit"),(0,o.kt)("p",null,"In this section, all tools and utility functions for mana will be outlined."),(0,o.kt)("h4",{id:"mana-related-api-endpoints"},"Mana Related API endpoints"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"/info"),": Add own mana in node info response."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"value/allowedManaPledge"),": Endpoint that clients can query to determine which nodeIDs are allowed as part of\n",(0,o.kt)("inlineCode",{parentName:"li"},"accessMana")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"consensusMana")," fields in a transaction."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"value/sendTransactionByJson"),": Add ",(0,o.kt)("inlineCode",{parentName:"li"},"accessMana"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"consensusMana")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"timestamp")," fields to the JSON request.")),(0,o.kt)("p",null,"Add a new ",(0,o.kt)("inlineCode",{parentName:"p"},"mana")," endpoint route:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"/mana"),": Return access and consensus mana of the node."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"/mana/all"),": Return whole mana map (mana perception of the node)."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"/mana/access/nhighest"),": Return ",(0,o.kt)("inlineCode",{parentName:"li"},"n")," highest access mana holder ",(0,o.kt)("inlineCode",{parentName:"li"},"nodeIDs")," and their access mana values."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"/mana/consensus/nhighest"),": Return ",(0,o.kt)("inlineCode",{parentName:"li"},"n")," highest consensus mana holder ",(0,o.kt)("inlineCode",{parentName:"li"},"nodeIDs")," and their consensus mana values."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"/mana/percentile"),": Return the top percentile the node belongs to relative to the network. For example, if there are 100 nodes in the\nnetwork owning mana, and a node is the 13th richest, it means that is part of the top 13% of mana holders, but not the\ntop 12%.")),(0,o.kt)("h4",{id:"metrics-collection"},"Metrics collection"),(0,o.kt)("p",null,"To study the mana module, following metrics could be gathered:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Amount of consensus and access mana present in the network. (amount varies because of ",(0,o.kt)("inlineCode",{parentName:"li"},"Base Mana 2"),")."),(0,o.kt)("li",{parentName:"ul"},"Amount of mana each node holds."),(0,o.kt)("li",{parentName:"ul"},"Number of (and amount of mana) a node was pledged with mana in the last ",(0,o.kt)("inlineCode",{parentName:"li"},"t")," interval."),(0,o.kt)("li",{parentName:"ul"},"Mana development of a particular node over time."),(0,o.kt)("li",{parentName:"ul"},"Mana percentile development of a node over time."),(0,o.kt)("li",{parentName:"ul"},"Average pledge amount of a node. (how much mana it receives on average with one pledge)"),(0,o.kt)("li",{parentName:"ul"},"Mean and median mana holdings of nodes in the network. Shows how even mana distribution is."),(0,o.kt)("li",{parentName:"ul"},"Average mana of neighbors.")),(0,o.kt)("h4",{id:"visualization"},"Visualization"),(0,o.kt)("p",null,"Each node calculates mana locally, not only for themselves, but for all nodes in the network that it knows. As a result,\nmana perception of nodes may not be exactly the same at all times (due to network delay, processing capabilities), but\nshould converge to the same state. A big question for visualization is which node's viewpoint to base mana visualization on? "),(0,o.kt)("p",null,"When running a node, operators will be shown the mana perception of their own node, but it also makes sense to\ndisplay the perception of high mana nodes as the global mana perception. First, let's look at how local mana perception\nis visualized for a node:"),(0,o.kt)("h5",{id:"local-perception"},"Local Perception"),(0,o.kt)("p",null,"There are two ways to visualize mana in GoShimmer:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Node Local Dashboard"),(0,o.kt)("li",{parentName:"ol"},"Grafana Dashboard")),(0,o.kt)("p",null,"While ",(0,o.kt)("inlineCode",{parentName:"p"},"Local Dashboard")," gives flexibility in what and how to visualize, ",(0,o.kt)("inlineCode",{parentName:"p"},"Grafana Dashboard")," is better at storing historic\ndata but can only visualize time series. Therefore, both of these ways will be utilized, depending on which suits the best."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"Local Dashboard")," visualization:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Histogram of mana distribution within the network."),(0,o.kt)("li",{parentName:"ul"},"List of ",(0,o.kt)("inlineCode",{parentName:"li"},"n")," richest mana nodes, ordered."),(0,o.kt)("li",{parentName:"ul"},"Mana rank of node.")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"Grafana Dashboard")," visualization:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Mana of a particular node with respect to time.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Amount of mana in the network.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Average pledge amount of a node.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Mean and median mana holdings of nodes.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Mana rank of the node over time.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Average mana of neighbors."),(0,o.kt)("h5",{parentName:"li",id:"global-perception"},"Global Perception"))),(0,o.kt)("p",null,"Additionally, the GoShimmer Analyzer (analysis server) could be updated:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Autopeering node graph, where size of a node corresponds to its mana value."),(0,o.kt)("li",{parentName:"ul"},"Some previously described metrics could be visualized here as well, to give the chance to people without\na node to take a look. As an input, a high mana node's perception should be used.")))}u.isMDXComponent=!0},35085:function(e,a,n){a.Z=n.p+"assets/files/mana-2744403e9cd06bba40f66102157f662d.png"},18029:function(e,a,n){a.Z=n.p+"assets/images/mana-2744403e9cd06bba40f66102157f662d.png"},3905:function(e,a,n){n.d(a,{Zo:function(){return p},kt:function(){return u}});var t=n(67294);function i(e,a,n){return a in e?Object.defineProperty(e,a,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[a]=n,e}function o(e,a){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);a&&(t=t.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),n.push.apply(n,t)}return n}function l(e){for(var a=1;a<arguments.length;a++){var n=null!=arguments[a]?arguments[a]:{};a%2?o(Object(n),!0).forEach((function(a){i(e,a,n[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(n,a))}))}return e}function s(e,a){if(null==e)return{};var n,t,i=function(e,a){if(null==e)return{};var n,t,i={},o=Object.keys(e);for(t=0;t<o.length;t++)n=o[t],a.indexOf(n)>=0||(i[n]=e[n]);return i}(e,a);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(t=0;t<o.length;t++)n=o[t],a.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var r=t.createContext({}),d=function(e){var a=t.useContext(r),n=a;return e&&(n="function"==typeof e?e(a):l(l({},a),e)),n},p=function(e){var a=d(e.components);return t.createElement(r.Provider,{value:a},e.children)},m={inlineCode:"code",wrapper:function(e){var a=e.children;return t.createElement(t.Fragment,{},a)}},c=t.forwardRef((function(e,a){var n=e.components,i=e.mdxType,o=e.originalType,r=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),c=d(n),u=i,h=c["".concat(r,".").concat(u)]||c[u]||m[u]||o;return n?t.createElement(h,l(l({ref:a},p),{},{components:n})):t.createElement(h,l({ref:a},p))}));function u(e,a){var n=arguments,i=a&&a.mdxType;if("string"==typeof e||i){var o=n.length,l=new Array(o);l[0]=c;var s={};for(var r in a)hasOwnProperty.call(a,r)&&(s[r]=a[r]);s.originalType=e,s.mdxType="string"==typeof e?e:i,l[1]=s;for(var d=2;d<o;d++)l[d]=n[d];return t.createElement.apply(null,l)}return t.createElement.apply(null,n)}c.displayName="MDXCreateElement"}}]);