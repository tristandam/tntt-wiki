"use strict";(self.webpackChunkiota_wiki=self.webpackChunkiota_wiki||[]).push([[94456],{36054:function(e){e.exports=JSON.parse('{"pluginId":"smart-contracts","version":"current","label":"Next","banner":null,"badge":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"tutorialSidebar":[{"type":"link","label":"Overview","href":"/smart-contracts/overview","docId":"overview"},{"type":"category","label":"Core Concepts","items":[{"type":"link","label":"Smart Contracts","href":"/smart-contracts/guide/core_concepts/smart-contracts","docId":"guide/core_concepts/smart-contracts"},{"type":"link","label":"ISCP Architecture","href":"/smart-contracts/guide/core_concepts/iscp-architecture","docId":"guide/core_concepts/iscp-architecture"},{"type":"link","label":"Committees and Validators","href":"/smart-contracts/guide/core_concepts/validators","docId":"guide/core_concepts/validators"},{"type":"link","label":"Consensus","href":"/smart-contracts/guide/core_concepts/consensus","docId":"guide/core_concepts/consensus"},{"type":"link","label":"State, Transitions and State Anchoring","href":"/smart-contracts/guide/core_concepts/states","docId":"guide/core_concepts/states"},{"type":"link","label":"Anatomy of a Smart Contract","href":"/smart-contracts/guide/core_concepts/smart-contract-anatomy","docId":"guide/core_concepts/smart-contract-anatomy"},{"type":"link","label":"Sandbox Interface","href":"/smart-contracts/guide/core_concepts/sandbox","docId":"guide/core_concepts/sandbox"},{"type":"category","label":"Core Contracts","items":[{"type":"link","label":"Overview","href":"/smart-contracts/guide/core_concepts/core_contracts/overview","docId":"guide/core_concepts/core_contracts/overview"},{"type":"link","label":"Root","href":"/smart-contracts/guide/core_concepts/core_contracts/root","docId":"guide/core_concepts/core_contracts/root"},{"type":"link","label":"Default","href":"/smart-contracts/guide/core_concepts/core_contracts/default","docId":"guide/core_concepts/core_contracts/default"},{"type":"link","label":"Accounts","href":"/smart-contracts/guide/core_concepts/core_contracts/accounts","docId":"guide/core_concepts/core_contracts/accounts"},{"type":"link","label":"Blob","href":"/smart-contracts/guide/core_concepts/core_contracts/blob","docId":"guide/core_concepts/core_contracts/blob"},{"type":"link","label":"Blocklog","href":"/smart-contracts/guide/core_concepts/core_contracts/blocklog","docId":"guide/core_concepts/core_contracts/blocklog"},{"type":"link","label":"Governance","href":"/smart-contracts/guide/core_concepts/core_contracts/governance","docId":"guide/core_concepts/core_contracts/governance"}],"collapsed":true,"collapsible":true},{"type":"category","label":"Accounts","items":[{"type":"link","label":"How Accounts Work","href":"/smart-contracts/guide/core_concepts/accounts/how-accounts-work","docId":"guide/core_concepts/accounts/how-accounts-work"},{"type":"link","label":"How To Deposit To a Chain","href":"/smart-contracts/guide/core_concepts/accounts/how-to-deposit-to-a-chain","docId":"guide/core_concepts/accounts/how-to-deposit-to-a-chain"},{"type":"link","label":"How To Withdraw From a Chain","href":"/smart-contracts/guide/core_concepts/accounts/how-to-withdraw-from-a-chain","docId":"guide/core_concepts/accounts/how-to-withdraw-from-a-chain"},{"type":"link","label":"View Account Balances","href":"/smart-contracts/guide/core_concepts/accounts/view-account-balances","docId":"guide/core_concepts/accounts/view-account-balances"},{"type":"link","label":"The Common Account","href":"/smart-contracts/guide/core_concepts/accounts/the-common-account","docId":"guide/core_concepts/accounts/the-common-account"}],"collapsed":true,"collapsible":true},{"type":"category","label":"Interacting With Smart Contracts","items":[{"type":"link","label":"On-ledger Requests","href":"/smart-contracts/guide/core_concepts/smartcontract-interaction/on-ledger-requests","docId":"guide/core_concepts/smartcontract-interaction/on-ledger-requests"},{"type":"link","label":"Off-ledger Requests","href":"/smart-contracts/guide/core_concepts/smartcontract-interaction/off-ledger-requests","docId":"guide/core_concepts/smartcontract-interaction/off-ledger-requests"}],"collapsed":true,"collapsible":true},{"type":"category","label":"Solo","items":[{"type":"link","label":"Solo","href":"/smart-contracts/guide/solo/what-is-solo","docId":"guide/solo/what-is-solo"},{"type":"link","label":"First Example","href":"/smart-contracts/guide/solo/first-example","docId":"guide/solo/first-example"},{"type":"link","label":"Tokens and the UTXO Ledger","href":"/smart-contracts/guide/solo/tokens-and-utxos","docId":"guide/solo/tokens-and-utxos"},{"type":"link","label":"Invoking a Smart Contract","href":"/smart-contracts/guide/solo/invoking-sc","docId":"guide/solo/invoking-sc"},{"type":"link","label":"Calling a View","href":"/smart-contracts/guide/solo/view-sc","docId":"guide/solo/view-sc"},{"type":"link","label":"Error Handling","href":"/smart-contracts/guide/solo/error-handling","docId":"guide/solo/error-handling"},{"type":"link","label":"Account Balances","href":"/smart-contracts/guide/solo/balances","docId":"guide/solo/balances"},{"type":"link","label":"Sending tokens to a Smart Contract","href":"/smart-contracts/guide/solo/sending-funds","docId":"guide/solo/sending-funds"},{"type":"link","label":"Return of tokens in case of failure","href":"/smart-contracts/guide/solo/reimbursed-funds","docId":"guide/solo/reimbursed-funds"},{"type":"link","label":"Sending tokens from ISCP to the Tangle","href":"/smart-contracts/guide/solo/sending-funds-sc","docId":"guide/solo/sending-funds-sc"}],"collapsed":true,"collapsible":true}],"collapsed":true,"collapsible":true},{"type":"category","label":"ISCP Chains and Nodes","items":[{"type":"link","label":"Running a Node","href":"/smart-contracts/guide/chains_and_nodes/running-a-node","docId":"guide/chains_and_nodes/running-a-node"},{"type":"link","label":"Using Docker (Standalone)","href":"/smart-contracts/guide/chains_and_nodes/docker_standalone","docId":"guide/chains_and_nodes/docker_standalone"},{"type":"link","label":"Configuring wasp-cli","href":"/smart-contracts/guide/chains_and_nodes/wasp-cli","docId":"guide/chains_and_nodes/wasp-cli"},{"type":"link","label":"Setting Up a Chain","href":"/smart-contracts/guide/chains_and_nodes/setting-up-a-chain","docId":"guide/chains_and_nodes/setting-up-a-chain"},{"type":"link","label":"Chain Management","href":"/smart-contracts/guide/chains_and_nodes/chain-management","docId":"guide/chains_and_nodes/chain-management"},{"type":"link","label":"Testnet","href":"/smart-contracts/guide/chains_and_nodes/testnet","docId":"guide/chains_and_nodes/testnet"}],"collapsed":true,"collapsible":true},{"type":"category","label":"Wasm VM","items":[{"type":"category","label":"Introduction","items":[{"type":"link","label":"Wasm VM for ISCP","href":"/smart-contracts/guide/wasm_vm/intro","docId":"guide/wasm_vm/intro"},{"type":"link","label":"Data Access Proxies","href":"/smart-contracts/guide/wasm_vm/proxies","docId":"guide/wasm_vm/proxies"},{"type":"link","label":"WasmLib Data Types","href":"/smart-contracts/guide/wasm_vm/types","docId":"guide/wasm_vm/types"},{"type":"link","label":"Function Call Context","href":"/smart-contracts/guide/wasm_vm/context","docId":"guide/wasm_vm/context"}],"collapsed":true,"collapsible":true},{"type":"category","label":"Schema tool","items":[{"type":"link","label":"Smart Contract Schema Tool","href":"/smart-contracts/guide/schema/","docId":"guide/schema/schema"},{"type":"link","label":"Using the Schema Tool","href":"/smart-contracts/guide/schema/usage","docId":"guide/schema/usage"},{"type":"link","label":"Structured Data Types","href":"/smart-contracts/guide/schema/structs","docId":"guide/schema/structs"},{"type":"link","label":"Type Definitions","href":"/smart-contracts/guide/schema/typedefs","docId":"guide/schema/typedefs"},{"type":"link","label":"Smart Contract State","href":"/smart-contracts/guide/schema/state","docId":"guide/schema/state"},{"type":"link","label":"Triggering Events","href":"/smart-contracts/guide/schema/events","docId":"guide/schema/events"},{"type":"link","label":"Function Definitions","href":"/smart-contracts/guide/schema/funcs","docId":"guide/schema/funcs"},{"type":"link","label":"Limiting Access","href":"/smart-contracts/guide/schema/access","docId":"guide/schema/access"},{"type":"link","label":"Function Parameters","href":"/smart-contracts/guide/schema/params","docId":"guide/schema/params"},{"type":"link","label":"Function Results","href":"/smart-contracts/guide/schema/results","docId":"guide/schema/results"},{"type":"link","label":"Thunk Functions","href":"/smart-contracts/guide/schema/thunks","docId":"guide/schema/thunks"},{"type":"link","label":"View-Only Functions","href":"/smart-contracts/guide/schema/views","docId":"guide/schema/views"},{"type":"link","label":"Smart Contract Initialization","href":"/smart-contracts/guide/schema/init","docId":"guide/schema/init"},{"type":"link","label":"Token Transfers","href":"/smart-contracts/guide/schema/transfers","docId":"guide/schema/transfers"},{"type":"link","label":"Function Descriptors","href":"/smart-contracts/guide/schema/funcdesc","docId":"guide/schema/funcdesc"},{"type":"link","label":"Calling Functions","href":"/smart-contracts/guide/schema/call","docId":"guide/schema/call"},{"type":"link","label":"Posting Asynchronous Requests","href":"/smart-contracts/guide/schema/post","docId":"guide/schema/post"},{"type":"link","label":"Testing Smart Contracts","href":"/smart-contracts/guide/schema/test","docId":"guide/schema/test"},{"type":"link","label":"Example Tests","href":"/smart-contracts/guide/schema/examples","docId":"guide/schema/examples"},{"type":"link","label":"Colored Tokens and Time Locks","href":"/smart-contracts/guide/schema/timelock","docId":"guide/schema/timelock"}],"collapsed":true,"collapsible":true}],"collapsed":true,"collapsible":true},{"type":"category","label":"EVM","items":[{"type":"link","label":"Introduction","href":"/smart-contracts/guide/evm/introduction","docId":"guide/evm/introduction"},{"type":"link","label":"Limitations","href":"/smart-contracts/guide/evm/limitations","docId":"guide/evm/limitations"},{"type":"link","label":"Creating a Chain","href":"/smart-contracts/guide/evm/create-chain","docId":"guide/evm/create-chain"},{"type":"link","label":"Tooling","href":"/smart-contracts/guide/evm/tooling","docId":"guide/evm/tooling"},{"type":"category","label":"Examples","items":[{"type":"link","label":"Example Contract","href":"/smart-contracts/guide/evm/examples/introduction","docId":"guide/evm/examples/introduction"},{"type":"link","label":"ERC20","href":"/smart-contracts/guide/evm/examples/ERC20","docId":"guide/evm/examples/ERC20"},{"type":"link","label":"ERC721","href":"/smart-contracts/guide/evm/examples/ERC721","docId":"guide/evm/examples/ERC721"}],"collapsed":true,"collapsible":true}],"collapsed":true,"collapsible":true},{"type":"category","label":"Example projects","items":[{"type":"link","label":"Fair Roulette","href":"/smart-contracts/guide/example_projects/fair_roulette","docId":"guide/example_projects/fair_roulette"}],"collapsed":true,"collapsible":true},{"type":"category","label":"Development tools","items":[{"type":"link","label":"Preconfigured Development Docker setup","href":"/smart-contracts/guide/development_tools/docker_preconfigured","docId":"guide/development_tools/docker_preconfigured"}],"collapsed":true,"collapsible":true},{"type":"link","label":"Contribute","href":"/smart-contracts/contribute","docId":"contribute"},{"type":"link","label":"Metrics","href":"/smart-contracts/metrics","docId":"metrics"}]},"docs":{"contribute":{"id":"contribute","title":"contribute","description":"How to contribute to IOTA Smart Contracts. How to create better pull requests by running tests and the linter locally.","sidebar":"tutorialSidebar"},"guide/chains_and_nodes/chain-management":{"id":"guide/chains_and_nodes/chain-management","title":"chain-management","description":"How to manage a chain using the Grafana dashboard, a client to receive published events, logging and validators.","sidebar":"tutorialSidebar"},"guide/chains_and_nodes/docker_standalone":{"id":"guide/chains_and_nodes/docker_standalone","title":"docker_standalone","description":"How to run a Wasp node in using Docker. Build the image, configure it, run it.","sidebar":"tutorialSidebar"},"guide/chains_and_nodes/publisher":{"id":"guide/chains_and_nodes/publisher","title":"publisher","description":"Publishing important events via a Nanomsg message stream. Subscribing to a stream with a client. Message format description."},"guide/chains_and_nodes/running-a-node":{"id":"guide/chains_and_nodes/running-a-node","title":"running-a-node","description":"How to run a node. Requirements, configuration parameters, dashboard configuration and tests.","sidebar":"tutorialSidebar"},"guide/chains_and_nodes/setting-up-a-chain":{"id":"guide/chains_and_nodes/setting-up-a-chain","title":"setting-up-a-chain","description":"Setting up a chain requirements, configuration parameters, validators and tests.","sidebar":"tutorialSidebar"},"guide/chains_and_nodes/testnet":{"id":"guide/chains_and_nodes/testnet","title":"testnet","description":"A public testnet for developers to try out smart contracts","sidebar":"tutorialSidebar"},"guide/chains_and_nodes/wasp-cli":{"id":"guide/chains_and_nodes/wasp-cli","title":"wasp-cli","description":"How to configure the wasp-cli. Requirements and configuration parameters.","sidebar":"tutorialSidebar"},"guide/core_concepts/accounts/how-accounts-work":{"id":"guide/core_concepts/accounts/how-accounts-work","title":"how-accounts-work","description":"IOTA Smart Contracts chains keeps a ledger of on-chain account balances. On-chain accounts are identified by an AgentID.","sidebar":"tutorialSidebar"},"guide/core_concepts/accounts/how-to-deposit-to-a-chain":{"id":"guide/core_concepts/accounts/how-to-deposit-to-a-chain","title":"how-to-deposit-to-a-chain","description":"The `deposit` entrypoint credits the transferred IOTAS into your on-chain account.","sidebar":"tutorialSidebar"},"guide/core_concepts/accounts/how-to-withdraw-from-a-chain":{"id":"guide/core_concepts/accounts/how-to-withdraw-from-a-chain","title":"how-to-withdraw-from-a-chain","description":"The `withdraw` endpoint sends funds owned by the callee to their L1 address.","sidebar":"tutorialSidebar"},"guide/core_concepts/accounts/the-common-account":{"id":"guide/core_concepts/accounts/the-common-account","title":"the-common-account","description":"The common account is controlled by the chain owner, and is used to store funds collected by fees, invalid contracts or sent to the L1 chain address.","sidebar":"tutorialSidebar"},"guide/core_concepts/accounts/view-account-balances":{"id":"guide/core_concepts/accounts/view-account-balances","title":"view-account-balances","description":"The Accounts contract provides the balance, totalAssets and accounts views.","sidebar":"tutorialSidebar"},"guide/core_concepts/consensus":{"id":"guide/core_concepts/consensus","title":"consensus","description":"IOTA Smart Contracts Consensus","sidebar":"tutorialSidebar"},"guide/core_concepts/core_contracts/accounts":{"id":"guide/core_concepts/core_contracts/accounts","title":"accounts","description":"The `accounts` contract keeps a consistent ledger of on-chain accounts in its state for the agents that control them. There are two types of agents who can do it, L1 addresses and smart contracts.","sidebar":"tutorialSidebar"},"guide/core_concepts/core_contracts/blob":{"id":"guide/core_concepts/core_contracts/blob","title":"blob","description":"The `blobs` contract maintains a registry of _blobs_ (a collection of arbitrary binary data) which are referenced from smart contracts via their hashes.","sidebar":"tutorialSidebar"},"guide/core_concepts/core_contracts/blocklog":{"id":"guide/core_concepts/core_contracts/blocklog","title":"blocklog","description":"The `blocklog` contract is to keep track of the blocks of requests that were processed by the chain. It also provides views to get request status, receipts, block information, or events.","sidebar":"tutorialSidebar"},"guide/core_concepts/core_contracts/default":{"id":"guide/core_concepts/core_contracts/default","title":"default","description":"The function of the `_default` contract is to provide a fall-back target for any request that cannot be handled by the chain, or contract, it was addressed to","sidebar":"tutorialSidebar"},"guide/core_concepts/core_contracts/governance":{"id":"guide/core_concepts/core_contracts/governance","title":"governance","description":"The `governance` contract defines the set of identities that constitute the state controller, who is the chain owner and  the fees for request execution.","sidebar":"tutorialSidebar"},"guide/core_concepts/core_contracts/overview":{"id":"guide/core_concepts/core_contracts/overview","title":"overview","description":"There currently are 6 core smart contracts that are always deployed on each  chain, root, _default, accounts, blob, blocklog, and governance.","sidebar":"tutorialSidebar"},"guide/core_concepts/core_contracts/root":{"id":"guide/core_concepts/core_contracts/root","title":"root","description":"The root contract is the first smart contract deployed on the chain. It functions as a smart contract factory for the chain, and manages chain ownership and fees.","sidebar":"tutorialSidebar"},"guide/core_concepts/iscp":{"id":"guide/core_concepts/iscp","title":"iscp","description":"IOTA Smart Contracts are IOTA\'s solution for running smart contracts on top of the IOTA tangle. Wasp is the node software we\'ve built to let you run smart contracts in a committee using a virtual machine of choice."},"guide/core_concepts/iscp-architecture":{"id":"guide/core_concepts/iscp-architecture","title":"iscp-architecture","description":"An overview of the IOTA Smart Contracts architecture.","sidebar":"tutorialSidebar"},"guide/core_concepts/sandbox":{"id":"guide/core_concepts/sandbox","title":"sandbox","description":"Smart Contracts can only interact with the world by using the Sandbox interface which provides limited and deterministic access to the state through a key/value storage abstraction.","sidebar":"tutorialSidebar"},"guide/core_concepts/smart-contract-anatomy":{"id":"guide/core_concepts/smart-contract-anatomy","title":"smart-contract-anatomy","description":"Each smart contract instance has a program with a collection of entry points and a state.","sidebar":"tutorialSidebar"},"guide/core_concepts/smart-contracts":{"id":"guide/core_concepts/smart-contracts","title":"smart-contracts","description":"Smart contracts are applications you can trust that run on a distributed network with multiple validators all executing and validating the same code.","sidebar":"tutorialSidebar"},"guide/core_concepts/smartcontract-interaction/off-ledger-requests":{"id":"guide/core_concepts/smartcontract-interaction/off-ledger-requests","title":"off-ledger-requests","description":"An Off-ledger request is not a transaction, but it contains the same information as an on-ledger request, and it is cryptographically signed. This kind of requests do not rely on the Tangle for confirmation, so they are much faster.","sidebar":"tutorialSidebar"},"guide/core_concepts/smartcontract-interaction/on-ledger-requests":{"id":"guide/core_concepts/smartcontract-interaction/on-ledger-requests","title":"on-ledger-requests","description":"Requests to the smart contract as transactions on the Tangle are called on-ledger requests.","sidebar":"tutorialSidebar"},"guide/core_concepts/states":{"id":"guide/core_concepts/states","title":"states","description":"The state of the chain consists of balances of native IOTA digital assets and a collection of key/value pairs which represents use case-specific data stored in the chain by its smart contracts outside the UTXO ledger.","sidebar":"tutorialSidebar"},"guide/core_concepts/validators":{"id":"guide/core_concepts/validators","title":"validators","description":"Each chain is run by a network of validator nodes which run a consensus on the chain state update.","sidebar":"tutorialSidebar"},"guide/development_tools/docker_preconfigured":{"id":"guide/development_tools/docker_preconfigured","title":"docker_preconfigured","description":"How to run the preconfigured Docker setup.","sidebar":"tutorialSidebar"},"guide/evm/create-chain":{"id":"guide/evm/create-chain","title":"create-chain","description":"Create, fund and, deploy a new EVM Chain using IOTA Smart Contracts.","sidebar":"tutorialSidebar"},"guide/evm/examples/ERC20":{"id":"guide/evm/examples/ERC20","title":"ERC20","description":"Solidity smart contract ERC20.","sidebar":"tutorialSidebar"},"guide/evm/examples/ERC721":{"id":"guide/evm/examples/ERC721","title":"ERC721","description":"Create and deploy a Solidity smart contract to mint NFTs using the ERC721 standard.","sidebar":"tutorialSidebar"},"guide/evm/examples/introduction":{"id":"guide/evm/examples/introduction","title":"introduction","description":"Solidity smart contract example.","sidebar":"tutorialSidebar"},"guide/evm/introduction":{"id":"guide/evm/introduction","title":"introduction","description":"The current release of IOTA Smart Contracts also has experimental support for EVM/Solidity,this means that existing smart contracts and tooling from other EVM based chains like Ethereum are fully compatible with EVM chains running on IOTA Smart Contracts.","sidebar":"tutorialSidebar"},"guide/evm/limitations":{"id":"guide/evm/limitations","title":"limitations","description":"EVM based smart contract limitations. The current implementation is fully sand-boxed and not aware of IOTA or IOTA Smart Contracts. You start an EVM chain with a new supply of EVM specific tokens assigned to a single address.","sidebar":"tutorialSidebar"},"guide/evm/tooling":{"id":"guide/evm/tooling","title":"tooling","description":"Existing EVM tooling is compatible and can be used directly with an IOTA Smart Contracts chain running EVM. You can configure hardhat, metamask, remix, Ether.js and Web3.js among others.","sidebar":"tutorialSidebar"},"guide/example_projects/fair_roulette":{"id":"guide/example_projects/fair_roulette","title":"fair_roulette","description":"An example game project with frontend and contract, demonstrating the development, setup, and interaction with a smart contract.","sidebar":"tutorialSidebar"},"guide/schema/access":{"id":"guide/schema/access","title":"access","description":"The optional access subsection indicates the agent who is allowed to access the function. When this definition is omitted, anyone is allowed to call the function.","sidebar":"tutorialSidebar"},"guide/schema/call":{"id":"guide/schema/call","title":"call","description":"Synchronous calls can only be made between contracts that are running on the same contract chain. When calling a smart contract function you can only access the memory assigned to that specific smart contract, the only way to share data between smart contracts that call each other is through function parameters and return values.","sidebar":"tutorialSidebar"},"guide/schema/events":{"id":"guide/schema/events","title":"events","description":"The smart contracts can trigger events that the user can subscribe to and that convey changes to its state.","sidebar":"tutorialSidebar"},"guide/schema/examples":{"id":"guide/schema/examples","title":"examples","description":"Use the SoloContext to create full-blown tests for the dividend example smart contract.","sidebar":"tutorialSidebar"},"guide/schema/funcdesc":{"id":"guide/schema/funcdesc","title":"funcdesc","description":"The schema tool provides us with an easy way to access to smart contract functions through function descriptors, which allow you to initiate the function by calling it synchronously, or posting a request to run it asynchronously.","sidebar":"tutorialSidebar"},"guide/schema/funcs":{"id":"guide/schema/funcs","title":"funcs","description":"The code generated for Funcs will be able to inspect and modify the smart contract state, whereas the code generated for Views will only be able to inspect the state.","sidebar":"tutorialSidebar"},"guide/schema/init":{"id":"guide/schema/init","title":"init","description":"The init function will automatically be called immediately after the first time the contract has been deployed to the VM.  This is a one-time initialization call, meant to be performed by the contract deployment mechanism.","sidebar":"tutorialSidebar"},"guide/schema/params":{"id":"guide/schema/params","title":"params","description":"The optional params subsection contains field definitions for each of the parameters that a function takes.","sidebar":"tutorialSidebar"},"guide/schema/post":{"id":"guide/schema/post","title":"post","description":"Asynchronous function calls between smart contracts are posted as requests on the Tangle. They allow you to invoke any smart contract function that is not a View on any smart contract chain.","sidebar":"tutorialSidebar"},"guide/schema/results":{"id":"guide/schema/results","title":"results","description":"The optional `results` subsection contains field definitions for each of the results a function produces. The layout of the field definitions is identical to that of the state field definitions","sidebar":"tutorialSidebar"},"guide/schema/schema":{"id":"guide/schema/schema","title":"schema","description":"To facilitate the code generation, we decided to use a _schema definition file_ for smart contracts. All aspects of a smart contract that should be known by someone who wants to use the contract are clearly defined in a schema definition file","sidebar":"tutorialSidebar"},"guide/schema/state":{"id":"guide/schema/state","title":"state","description":"The smart contract state storage on the host consists of a single key/value map, as long as you access the data in the same way that you used to store it, you will always get valid data back.","sidebar":"tutorialSidebar"},"guide/schema/structs":{"id":"guide/schema/structs","title":"structs","description":"You can use structs directly as a type in state storage definitions and the schema tool will automatically generate the proxy code to access it properly.","sidebar":"tutorialSidebar"},"guide/schema/test":{"id":"guide/schema/test","title":"test","description":"Testing of smart contracts happens in the Solo testing environment. This enables synchronous, deterministic testing of smart contract functionality without the overhead of having to start nodes, set up a committee, and send transactions over the Tangle","sidebar":"tutorialSidebar"},"guide/schema/thunks":{"id":"guide/schema/thunks","title":"thunks","description":"Thunk functions encapsulate access and parameter checking and set up the type-safe function-specific contexts. Thunks are used to insert operations at the beginning or end of the other function to adapt it to changing requirements","sidebar":"tutorialSidebar"},"guide/schema/timelock":{"id":"guide/schema/timelock","title":"timelock","description":"You can post a time-locked request by using the Delay() method. You can convert plan tokens to colored tokens using the Mint() method.","sidebar":"tutorialSidebar"},"guide/schema/transfers":{"id":"guide/schema/transfers","title":"transfers","description":"There are two methods in the IOTA Smart Contracts function context that deal with token balances. The balances() method can be used to determine the current total balance per token color. The incoming() method can be used to determine the amounts of incoming tokens per token color that were sent with the request to call the smart contract function.","sidebar":"tutorialSidebar"},"guide/schema/typedefs":{"id":"guide/schema/typedefs","title":"typedefs","description":"You can add a typedefs section to the schema definition file, where you can define a single type name for a container type. This way you can easily create containers that contain container types.","sidebar":"tutorialSidebar"},"guide/schema/usage":{"id":"guide/schema/usage","title":"usage","description":"The `schema` tool will assist in creating a smart contract unobtrusively as possible.","sidebar":"tutorialSidebar"},"guide/schema/views":{"id":"guide/schema/views","title":"views","description":"Views are smart contract functions that only allow you to retrieve state information about the smart contract. They have a special, limited IOTA Smart Contracts function context that does not allow them to change the smart contract state.","sidebar":"tutorialSidebar"},"guide/solo/balances":{"id":"guide/solo/balances","title":"balances","description":"Smart contracts can exchange assets between themselves on the same chain and also between different chains, as well as with addresses on the UTXO Ledger.","sidebar":"tutorialSidebar"},"guide/solo/error-handling":{"id":"guide/solo/error-handling","title":"error-handling","description":"Whatever happens during the execution of a smart contract\'s full entry point, processing of the request always results in the state transition.  The VM context catches exceptions (panics) in the program. Its consequences are recorded in the state of the chain during the fallback processing.","sidebar":"tutorialSidebar"},"guide/solo/first-example":{"id":"guide/solo/first-example","title":"first-example","description":"Example of a _Solo_ test. It deploys a new chain and invokes a function in the root contract.","sidebar":"tutorialSidebar"},"guide/solo/invoking-sc":{"id":"guide/solo/invoking-sc","title":"invoking-sc","description":"In Solo, you can post an on-ledger request with a single call to PostRequestSync.  Alternatively, you can post an off-ledger request by using chain.PostRequestOffLedger instead of PostRequestSync.","sidebar":"tutorialSidebar"},"guide/solo/reimbursed-funds":{"id":"guide/solo/reimbursed-funds","title":"reimbursed-funds","description":"In case of panic in the smart contract for whatever reason, the fallback logic of the ISCP VM returns all tokens (minus fees) to the sender.","sidebar":"tutorialSidebar"},"guide/solo/sending-funds":{"id":"guide/solo/sending-funds","title":"sending-funds","description":"The creator of the smart contract (and nobody else) may withdraw iotas to its address by sending a `withdrawIotas` request.","sidebar":"tutorialSidebar"},"guide/solo/sending-funds-sc":{"id":"guide/solo/sending-funds-sc","title":"sending-funds-sc","description":"Smart contract only allow their creator to withdraw tokens contained in the smart contract. If authorisation conditions are satisfied, the contract calls the transfer_to_address sandbox function to send all iotas, owned by the contract, to the caller\'s address.","sidebar":"tutorialSidebar"},"guide/solo/tokens-and-utxos":{"id":"guide/solo/tokens-and-utxos","title":"tokens-and-utxos","description":"The UTXO Ledger contains balances of colored tokens locked in addresses.  You can only move tokens on the UTXO Ledger by unlocking the corresponding address with its private key","sidebar":"tutorialSidebar"},"guide/solo/view-sc":{"id":"guide/solo/view-sc","title":"view-sc","description":"The basic principle of calling a view is similar to sending a request to the smart contract. The essential difference is that calling a view does not constitute an asynchronous transaction, it is just a direct synchronous call to the view entry point function, exposed by the smart contract.","sidebar":"tutorialSidebar"},"guide/solo/what-is-solo":{"id":"guide/solo/what-is-solo","title":"what-is-solo","description":"Solo is a testing framework that allows developers to validate real smart contracts and entire inter-chain protocols","sidebar":"tutorialSidebar"},"guide/wasm_vm/context":{"id":"guide/wasm_vm/context","title":"context","description":"The function call context provides as a predefined parameter to the smart contract function and allows you to access the functionality that the host sandbox interface provides.","sidebar":"tutorialSidebar"},"guide/wasm_vm/intro":{"id":"guide/wasm_vm/intro","title":"intro","description":"IOTA Smart Contracts provide a very flexible way of programming smart contracts by providing an API to a sandboxed environment that allows you to interact with IOTA Smart Contracts deterministically without any security risks.","sidebar":"tutorialSidebar"},"guide/wasm_vm/proxies":{"id":"guide/wasm_vm/proxies","title":"proxies","description":"As there is no way for the Wasm code to access any memory outside its own memory space, the WasmLib interface provides a number of proxies to make accessing data within the IOTA Smart Contracts sandbox as seamless as possible.","sidebar":"tutorialSidebar"},"guide/wasm_vm/types":{"id":"guide/wasm_vm/types","title":"types","description":"The WasmLib provides direct support for the basic value data types that are found in all programming languages, and WasmLib version of IOTA Smart Contracts-specific value data types.","sidebar":"tutorialSidebar"},"metrics":{"id":"metrics","title":"metrics","description":"IOTA Smart Contract Protocol is IOTA\'s solution for running smart contracts on top of the IOTA tangle.","sidebar":"tutorialSidebar"},"overview":{"id":"overview","title":"overview","description":"IOTA Smart Contracts allow you to run smart contracts on top of the IOTA Tangle.","sidebar":"tutorialSidebar"}}}')}}]);