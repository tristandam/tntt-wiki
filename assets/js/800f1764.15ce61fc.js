"use strict";(self.webpackChunkiota_wiki=self.webpackChunkiota_wiki||[]).push([[83593],{27701:function(e,n,t){t.r(n),t.d(n,{assets:function(){return m},contentTitle:function(){return u},default:function(){return _},frontMatter:function(){return c},metadata:function(){return h},toc:function(){return p}});var i=t(83117),r=t(80102),o=(t(67294),t(3905)),a=t(76018),s=t(71871),d=t(85317),l=["components"],c={title:"Resolve a DID history",sidebar_label:"Resolve a DID history",description:"Resolve a DID history using the IOTA Identity Rust Library or its WASM binding",image:"/img/Identity_icon.png",keywords:["Rust","WASM"]},u=void 0,h={unversionedId:"decentralized_identifiers/resolve_history",id:"decentralized_identifiers/resolve_history",title:"Resolve a DID history",description:"Resolve a DID history using the IOTA Identity Rust Library or its WASM binding",source:"@site/external/identity.rs/documentation/docs/decentralized_identifiers/resolve_history.mdx",sourceDirName:"decentralized_identifiers",slug:"/decentralized_identifiers/resolve_history",permalink:"/identity.rs/decentralized_identifiers/resolve_history",editUrl:"https://github.com/iotaledger/identity.rs/edit/dev/external/identity.rs/documentation/docs/decentralized_identifiers/resolve_history.mdx",tags:[],version:"current",frontMatter:{title:"Resolve a DID history",sidebar_label:"Resolve a DID history",description:"Resolve a DID history using the IOTA Identity Rust Library or its WASM binding",image:"/img/Identity_icon.png",keywords:["Rust","WASM"]},sidebar:"docs",previous:{title:"Resolve",permalink:"/identity.rs/decentralized_identifiers/resolve"},next:{title:"Create a Private Tangle",permalink:"/identity.rs/decentralized_identifiers/private_tangle"}},m={},p=[{value:"Example",id:"example",level:2}],y={toc:p};function _(e){var n=e.components,t=(0,r.Z)(e,l);return(0,o.kt)("wrapper",(0,i.Z)({},y,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h2",{id:"example"},"Example"),(0,o.kt)("p",null,"Below is an example that performs multiple integration chain updates, and demonstrates how to resolve the DID Document history to view these chains."),(0,o.kt)(a.Z,{groupId:"programming-languages",defaultValue:"rust",values:[{label:"Rust",value:"rust"},{label:"Node.js",value:"nodejs"}],mdxType:"Tabs"},(0,o.kt)(s.Z,{value:"rust",mdxType:"TabItem"},(0,o.kt)(d.Z,{className:"language-rust",mdxType:"CodeBlock"},'// Copyright 2020-2022 IOTA Stiftung\r\n// SPDX-License-Identifier: Apache-2.0\r\n\r\n//! Advanced example that performs multiple updates and demonstrates how to resolve the\r\n//! DID Document history to view them.\r\n//!\r\n//! cargo run --example did_history\r\n\r\nuse identity::core::json;\r\nuse identity::core::FromJson;\r\nuse identity::core::Timestamp;\r\nuse identity::crypto::KeyPair;\r\nuse identity::did::MethodScope;\r\nuse identity::did::Service;\r\nuse identity::did::DID;\r\nuse identity::iota::Client;\r\nuse identity::iota::DocumentHistory;\r\nuse identity::iota::Receipt;\r\nuse identity::iota::Result;\r\nuse identity::iota_core::IotaDocument;\r\nuse identity::iota_core::IotaService;\r\nuse identity::iota_core::IotaVerificationMethod;\r\nuse identity::prelude::*;\r\n\r\nmod create_did;\r\n\r\n#[rustfmt::skip]\r\n#[tokio::main]\r\nasync fn main() -> Result<()> {\r\n  // Create a client instance to send messages to the Tangle.\r\n  let client: Client = Client::new().await?;\r\n\r\n  // ===========================================================================\r\n  // DID Creation\r\n  // ===========================================================================\r\n\r\n  // Create a signed DID Document and KeyPair (see "create_did.rs" example).\r\n  let (document, keypair, original_receipt): (IotaDocument, KeyPair, Receipt) = create_did::run().await?;\r\n\r\n  // ===========================================================================\r\n  // Integration Chain Spam\r\n  // ===========================================================================\r\n\r\n  // Publish several spam messages to the same index as the integration chain on the Tangle.\r\n  // These are not valid DID messages and are simply to demonstrate that invalid messages\r\n  // can be included in the history for debugging invalid DID documents.\r\n  let int_index: &str = document.integration_index();\r\n  client.publish_json(int_index, &json!({ "intSpam:1": true })).await?;\r\n  client.publish_json(int_index, &json!({ "intSpam:2": true })).await?;\r\n  client.publish_json(int_index, &json!({ "intSpam:3": true })).await?;\r\n  client.publish_json(int_index, &json!({ "intSpam:4": true })).await?;\r\n  client.publish_json(int_index, &json!({ "intSpam:5": true })).await?;\r\n\r\n  // ===========================================================================\r\n  // Integration Chain Update 1\r\n  // ===========================================================================\r\n\r\n  // Prepare an integration chain update, which writes the full updated DID document to the Tangle.\r\n  let int_doc_1 = {\r\n    let mut int_doc_1 = document.clone();\r\n\r\n    // Add a new Service with the tag "linked-domain-1".\r\n    let service: IotaService = Service::from_json_value(json!({\r\n      "id": int_doc_1.id().to_url().join("#linked-domain-1")?,\r\n      "type": "LinkedDomains",\r\n      "serviceEndpoint": "https://iota.org/"\r\n    }))?;\r\n    assert!(int_doc_1.insert_service(service));\r\n\r\n    // Add a second Service with the tag "linked-domain-2".\r\n    let service: IotaService = Service::from_json_value(json!({\r\n      "id": int_doc_1.id().to_url().join("#linked-domain-2")?,\r\n      "type": "LinkedDomains",\r\n      "serviceEndpoint": {\r\n        "origins": ["https://iota.org/", "https://example.com/"]\r\n      }\r\n    }))?;\r\n    assert!(int_doc_1.insert_service(service));\r\n\r\n    // Add a new VerificationMethod with a new KeyPair, with the tag "keys-1"\r\n    let keys_1: KeyPair = KeyPair::new(KeyType::Ed25519)?;\r\n    let method_1: IotaVerificationMethod = IotaVerificationMethod::new(int_doc_1.id().clone(), keys_1.type_(), keys_1.public(), "keys-1")?;\r\n    assert!(int_doc_1.insert_method(method_1, MethodScope::VerificationMethod).is_ok());\r\n\r\n    // Add the `message_id` of the previous message in the chain.\r\n    // This is REQUIRED in order for the messages to form a chain.\r\n    // Skipping / forgetting this will render the publication useless.\r\n    int_doc_1.metadata.previous_message_id = *original_receipt.message_id();\r\n    int_doc_1.metadata.updated = Some(Timestamp::now_utc());\r\n\r\n    // Sign the DID Document with the original private key.\r\n    int_doc_1.sign_self(keypair.private(), int_doc_1.default_signing_method()?.id().clone())?;\r\n\r\n    int_doc_1\r\n  };\r\n\r\n  // Publish the updated DID Document to the Tangle, updating the integration chain.\r\n  // This may take a few seconds to complete proof-of-work.\r\n  let int_receipt_1: Receipt = client.publish_document(&int_doc_1).await?;\r\n\r\n  // ===========================================================================\r\n  // DID History 1\r\n  // ===========================================================================\r\n\r\n  // Retrieve the message history of the DID.\r\n  let history_1: DocumentHistory = client.resolve_history(document.id()).await?;\r\n\r\n  // The history shows two documents in the integration chain.\r\n  println!("History (1) = {:#?}", history_1);\r\n\r\n  // ===========================================================================\r\n  // Integration Chain Update 2\r\n  // ===========================================================================\r\n\r\n  // Publish a second integration chain update\r\n  let int_doc_2 = {\r\n    let mut int_doc_2 = int_doc_1.clone();\r\n\r\n    // Remove the #keys-1 VerificationMethod\r\n    int_doc_2.remove_method(&int_doc_2.id().to_url().join("#keys-1")?)?;\r\n\r\n    // Remove the #linked-domain-1 Service\r\n    int_doc_2.remove_service(&int_doc_2.id().to_url().join("#linked-domain-1")?)?;\r\n\r\n    // Add a VerificationMethod with a new KeyPair, called "keys-2"\r\n    let keys_2: KeyPair = KeyPair::new(KeyType::Ed25519)?;\r\n    let method_2: IotaVerificationMethod = IotaVerificationMethod::new(int_doc_2.id().clone(), keys_2.type_(), keys_2.public(), "keys-2")?;\r\n    assert!(int_doc_2.insert_method(method_2, MethodScope::VerificationMethod).is_ok());\r\n\r\n    // Note: the `previous_message_id` points to the `message_id` of the last integration chain\r\n    //       update.\r\n    int_doc_2.metadata.previous_message_id = *int_receipt_1.message_id();\r\n    int_doc_2.metadata.updated = Some(Timestamp::now_utc());\r\n\r\n    int_doc_2.sign_self(keypair.private(), int_doc_2.default_signing_method()?.id().clone())?;\r\n    int_doc_2\r\n  };\r\n  let _int_receipt_2: Receipt = client.publish_document(&int_doc_2).await?;\r\n\r\n  // ===========================================================================\r\n  // DID History 2\r\n  // ===========================================================================\r\n\r\n  // Retrieve the updated message history of the DID.\r\n  let history_2: DocumentHistory = client.resolve_history(document.id()).await?;\r\n\r\n  // The history now shows three documents in the integration chain.\r\n  println!("History (2) = {:#?}", history_2);\r\n\r\n  Ok(())\r\n}\r\n')),(0,o.kt)(s.Z,{value:"nodejs",mdxType:"TabItem"},(0,o.kt)(d.Z,{className:"language-javascript",mdxType:"CodeBlock"},'// Copyright 2020-2022 IOTA Stiftung\r\n// SPDX-License-Identifier: Apache-2.0\r\n\r\nimport {\r\n    Client,\r\n    Document,\r\n    KeyPair,\r\n    KeyType,\r\n    MethodScope,\r\n    Service,\r\n    Timestamp,\r\n    VerificationMethod\r\n} from \'@iota/identity-wasm\';\r\nimport {createIdentity} from "./create_did";\r\n\r\n/**\r\n Advanced example that performs multiple updates and demonstrates how to resolve the DID Document history to view them.\r\n\r\n @param {{network: Network, explorer: ExplorerUrl}} clientConfig\r\n **/\r\nasync function resolveHistory(clientConfig) {\r\n    // Create a client instance to publish messages to the configured Tangle network.\r\n    const client = await Client.fromConfig({\r\n        network: clientConfig.network\r\n    });\r\n\r\n    // ===========================================================================\r\n    // DID Creation\r\n    // ===========================================================================\r\n\r\n    // Create a new identity (see "create_did.js" example).\r\n    const {doc, key, receipt: originalReceipt} = await createIdentity(clientConfig);\r\n\r\n    // ===========================================================================\r\n    // Integration Chain Spam\r\n    // ===========================================================================\r\n\r\n    // Publish several spam messages to the same index as the integration chain on the Tangle.\r\n    // These are not valid DID documents and are simply to demonstrate that invalid messages can be\r\n    // included in the history, potentially for debugging invalid DID documents.\r\n    const intIndex = doc.integrationIndex();\r\n    await client.publishJSON(intIndex, {"intSpam:1": true});\r\n    await client.publishJSON(intIndex, {"intSpam:2": true});\r\n    await client.publishJSON(intIndex, {"intSpam:3": true});\r\n    await client.publishJSON(intIndex, {"intSpam:4": true});\r\n    await client.publishJSON(intIndex, {"intSpam:5": true});\r\n\r\n    // ===========================================================================\r\n    // Integration Chain Update 1\r\n    // ===========================================================================\r\n\r\n    // Prepare an integration chain update, which writes the full updated DID document to the Tangle.\r\n    const intDoc1 = doc.clone();\r\n\r\n    // Add a new Service with the tag "linked-domain-1"\r\n    const service1 = new Service({\r\n        id: intDoc1.id().toUrl().join("#linked-domain-1"),\r\n        type: "LinkedDomains",\r\n        serviceEndpoint: "https://iota.org",\r\n    });\r\n    intDoc1.insertService(service1);\r\n\r\n    // Add a second Service with the tag "linked-domain-2"\r\n    const service2 = new Service({\r\n        id: intDoc1.id().toUrl().join("#linked-domain-2"),\r\n        type: "LinkedDomains",\r\n        serviceEndpoint: {\r\n            "origins": ["https://iota.org/", "https://example.com/"]\r\n        },\r\n    });\r\n    intDoc1.insertService(service2);\r\n\r\n    // Add a new VerificationMethod with a new KeyPair, with the tag "keys-1"\r\n    const keys1 = new KeyPair(KeyType.Ed25519);\r\n    const method1 = new VerificationMethod(intDoc1.id(), keys1.type(), keys1.public(), "keys-1");\r\n    intDoc1.insertMethod(method1, MethodScope.VerificationMethod());\r\n\r\n    // Add the `messageId` of the previous message in the chain.\r\n    // This is REQUIRED in order for the messages to form a chain.\r\n    // Skipping / forgetting this will render the publication useless.\r\n    intDoc1.setMetadataPreviousMessageId(originalReceipt.messageId());\r\n    intDoc1.setMetadataUpdated(Timestamp.nowUTC());\r\n\r\n    // Sign the DID Document with the original private key.\r\n    intDoc1.signSelf(key, intDoc1.defaultSigningMethod().id());\r\n\r\n    // Publish the updated DID Document to the Tangle, updating the integration chain.\r\n    // This may take a few seconds to complete proof-of-work.\r\n    const intReceipt1 = await client.publishDocument(intDoc1);\r\n\r\n    // Log the results.\r\n    console.log(`Int. Chain Update (1): ${clientConfig.explorer.messageUrl(intReceipt1.messageId())}`);\r\n\r\n    // ===========================================================================\r\n    // DID History 1\r\n    // ===========================================================================\r\n\r\n    // Retrieve the message history of the DID.\r\n    const history1 = await client.resolveHistory(doc.id());\r\n\r\n    // The history shows two documents in the integration chain.\r\n    console.log(`History (1): ${JSON.stringify(history1, null, 2)}`);\r\n\r\n    // ===========================================================================\r\n    // Integration Chain Update 2\r\n    // ===========================================================================\r\n\r\n    // Publish a second integration chain update\r\n    let intDoc2 = Document.fromJSON(intDoc1.toJSON());\r\n\r\n    // Remove the #keys-1 VerificationMethod\r\n    intDoc2.removeMethod(intDoc2.id().toUrl().join("#keys-1"));\r\n\r\n    // Remove the #linked-domain-1 Service\r\n    intDoc2.removeService(intDoc2.id().toUrl().join("#linked-domain-1"));\r\n\r\n    // Add a VerificationMethod with a new KeyPair, called "keys-2"\r\n    const keys2 = new KeyPair(KeyType.Ed25519);\r\n    const method2 = new VerificationMethod(intDoc2.id(), keys2.type(), keys2.public(), "keys-2");\r\n    intDoc2.insertMethod(method2, MethodScope.VerificationMethod());\r\n\r\n    // Note: the `previous_message_id` points to the `message_id` of the last integration chain\r\n    //       update.\r\n    intDoc2.setMetadataPreviousMessageId(intReceipt1.messageId());\r\n    intDoc2.setMetadataUpdated(Timestamp.nowUTC());\r\n    intDoc2.signSelf(key, intDoc2.defaultSigningMethod().id());\r\n    const intReceipt2 = await client.publishDocument(intDoc2);\r\n\r\n    // Log the results.\r\n    console.log(`Int. Chain Update (2): ${clientConfig.explorer.messageUrl(intReceipt2.messageId())}`);\r\n\r\n    // ===========================================================================\r\n    // DID History 2\r\n    // ===========================================================================\r\n\r\n    // Retrieve the updated message history of the DID.\r\n    const history2 = await client.resolveHistory(doc.id());\r\n\r\n    // The history now shows three documents in the integration chain.\r\n    console.log(`History (2): ${JSON.stringify(history2, null, 2)}`);\r\n}\r\n\r\nexport {resolveHistory};\r\n'))))}_.isMDXComponent=!0},71871:function(e,n,t){t.d(n,{Z:function(){return r}});var i=t(67294);function r(e){var n=e.children,t=e.hidden,r=e.className;return i.createElement("div",{role:"tabpanel",hidden:t,className:r},n)}},76018:function(e,n,t){t.d(n,{Z:function(){return c}});var i=t(83117),r=t(67294),o=t(5730),a=t(37559),s=t(86010),d="tabItem_LplD";function l(e){var n,t,o,l=e.lazy,c=e.block,u=e.defaultValue,h=e.values,m=e.groupId,p=e.className,y=r.Children.map(e.children,(function(e){if((0,r.isValidElement)(e)&&void 0!==e.props.value)return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})),_=null!=h?h:y.map((function(e){var n=e.props;return{value:n.value,label:n.label,attributes:n.attributes}})),g=(0,a.lx)(_,(function(e,n){return e.value===n.value}));if(g.length>0)throw new Error('Docusaurus error: Duplicate values "'+g.map((function(e){return e.value})).join(", ")+'" found in <Tabs>. Every value needs to be unique.');var v=null===u?u:null!=(n=null!=u?u:null==(t=y.find((function(e){return e.props.default})))?void 0:t.props.value)?n:null==(o=y[0])?void 0:o.props.value;if(null!==v&&!_.some((function(e){return e.value===v})))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+v+'" but none of its children has the corresponding value. Available values are: '+_.map((function(e){return e.value})).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");var f=(0,a.UB)(),D=f.tabGroupChoices,w=f.setTabGroupChoices,k=(0,r.useState)(v),I=k[0],b=k[1],S=[],T=(0,a.o5)().blockElementScrollPositionUntilNextRender;if(null!=m){var x=D[m];null!=x&&x!==I&&_.some((function(e){return e.value===x}))&&b(x)}var M=function(e){var n=e.currentTarget,t=S.indexOf(n),i=_[t].value;i!==I&&(T(n),b(i),null!=m&&w(m,i))},R=function(e){var n,t=null;switch(e.key){case"ArrowRight":var i=S.indexOf(e.currentTarget)+1;t=S[i]||S[0];break;case"ArrowLeft":var r=S.indexOf(e.currentTarget)-1;t=S[r]||S[S.length-1]}null==(n=t)||n.focus()};return r.createElement("div",{className:"tabs-container"},r.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,s.Z)("tabs",{"tabs--block":c},p)},_.map((function(e){var n=e.value,t=e.label,o=e.attributes;return r.createElement("li",(0,i.Z)({role:"tab",tabIndex:I===n?0:-1,"aria-selected":I===n,key:n,ref:function(e){return S.push(e)},onKeyDown:R,onFocus:M,onClick:M},o,{className:(0,s.Z)("tabs__item",d,null==o?void 0:o.className,{"tabs__item--active":I===n})}),null!=t?t:n)}))),l?(0,r.cloneElement)(y.filter((function(e){return e.props.value===I}))[0],{className:"margin-vert--md"}):r.createElement("div",{className:"margin-vert--md"},y.map((function(e,n){return(0,r.cloneElement)(e,{key:n,hidden:e.props.value!==I})}))))}function c(e){var n=(0,o.Z)();return r.createElement(l,(0,i.Z)({key:String(n)},e))}}}]);